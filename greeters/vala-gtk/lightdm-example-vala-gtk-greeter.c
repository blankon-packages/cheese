/* lightdm-example-vala-gtk-greeter.c generated by valac 0.13.0, the Vala compiler
 * generated from lightdm-example-vala-gtk-greeter.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <lightdm/greeter.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>
#include <gobject/gvaluecollector.h>


#define TYPE_GREETER (greeter_get_type ())
#define GREETER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GREETER, Greeter))
#define GREETER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GREETER, GreeterClass))
#define IS_GREETER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GREETER))
#define IS_GREETER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GREETER))
#define GREETER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GREETER, GreeterClass))

typedef struct _Greeter Greeter;
typedef struct _GreeterClass GreeterClass;
typedef struct _GreeterPrivate GreeterPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _greeter_unref0(var) ((var == NULL) ? NULL : (var = (greeter_unref (var), NULL)))
typedef struct _ParamSpecGreeter ParamSpecGreeter;

struct _Greeter {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GreeterPrivate * priv;
};

struct _GreeterClass {
	GTypeClass parent_class;
	void (*finalize) (Greeter *self);
};

struct _GreeterPrivate {
	LdmGreeter* greeter;
	GtkEntry* username_entry;
	GtkEntry* password_entry;
	GtkLabel* message_label;
};

struct _ParamSpecGreeter {
	GParamSpec parent_instance;
};


static gpointer greeter_parent_class = NULL;

gpointer greeter_ref (gpointer instance);
void greeter_unref (gpointer instance);
GParamSpec* param_spec_greeter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_greeter (GValue* value, gpointer v_object);
void value_take_greeter (GValue* value, gpointer v_object);
gpointer value_get_greeter (const GValue* value);
GType greeter_get_type (void) G_GNUC_CONST;
#define GREETER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GREETER, GreeterPrivate))
enum  {
	GREETER_DUMMY_PROPERTY
};
Greeter* greeter_new (void);
Greeter* greeter_construct (GType object_type);
static void greeter_connect_cb (Greeter* self, LdmGreeter* greeter);
static void _greeter_connect_cb_ldm_greeter_connected (LdmGreeter* _sender, gpointer self);
static void greeter_show_prompt_cb (Greeter* self, LdmGreeter* greeter, const gchar* text, LdmPromptType type);
static void _greeter_show_prompt_cb_ldm_greeter_show_prompt (LdmGreeter* _sender, const gchar* text, LdmPromptType type, gpointer self);
static void greeter_show_message_cb (Greeter* self, LdmGreeter* greeter, const gchar* text, LdmMessageType type);
static void _greeter_show_message_cb_ldm_greeter_show_message (LdmGreeter* _sender, const gchar* text, LdmMessageType type, gpointer self);
static void greeter_authentication_complete_cb (Greeter* self, LdmGreeter* greeter);
static void _greeter_authentication_complete_cb_ldm_greeter_authentication_complete (LdmGreeter* _sender, gpointer self);
static void greeter_timed_login_cb (Greeter* self, LdmGreeter* greeter, const gchar* username);
static void _greeter_timed_login_cb_ldm_greeter_timed_login (LdmGreeter* _sender, const gchar* username, gpointer self);
static void greeter_quit_cb (Greeter* self, LdmGreeter* greeter);
static void _greeter_quit_cb_ldm_greeter_quit (LdmGreeter* _sender, gpointer self);
void greeter_start (Greeter* self);
static void greeter_username_activate_cb (Greeter* self, GtkEntry* entry);
static void greeter_password_activate_cb (Greeter* self, GtkEntry* entry);
static void _greeter_username_activate_cb_gtk_entry_activate (GtkEntry* _sender, gpointer self);
static void _greeter_password_activate_cb_gtk_entry_activate (GtkEntry* _sender, gpointer self);
static gint greeter_main (gchar** args, int args_length1);
static void greeter_finalize (Greeter* obj);


static void _greeter_connect_cb_ldm_greeter_connected (LdmGreeter* _sender, gpointer self) {
	greeter_connect_cb (self, _sender);
}


static void _greeter_show_prompt_cb_ldm_greeter_show_prompt (LdmGreeter* _sender, const gchar* text, LdmPromptType type, gpointer self) {
	greeter_show_prompt_cb (self, _sender, text, type);
}


static void _greeter_show_message_cb_ldm_greeter_show_message (LdmGreeter* _sender, const gchar* text, LdmMessageType type, gpointer self) {
	greeter_show_message_cb (self, _sender, text, type);
}


static void _greeter_authentication_complete_cb_ldm_greeter_authentication_complete (LdmGreeter* _sender, gpointer self) {
	greeter_authentication_complete_cb (self, _sender);
}


static void _greeter_timed_login_cb_ldm_greeter_timed_login (LdmGreeter* _sender, const gchar* username, gpointer self) {
	greeter_timed_login_cb (self, _sender, username);
}


static void _greeter_quit_cb_ldm_greeter_quit (LdmGreeter* _sender, gpointer self) {
	greeter_quit_cb (self, _sender);
}


Greeter* greeter_construct (GType object_type) {
	Greeter* self = NULL;
	LdmGreeter* _tmp0_ = NULL;
	self = (Greeter*) g_type_create_instance (object_type);
	_tmp0_ = ldm_greeter_new ();
	_g_object_unref0 (self->priv->greeter);
	self->priv->greeter = _tmp0_;
	g_signal_connect (self->priv->greeter, "connected", (GCallback) _greeter_connect_cb_ldm_greeter_connected, self);
	g_signal_connect (self->priv->greeter, "show-prompt", (GCallback) _greeter_show_prompt_cb_ldm_greeter_show_prompt, self);
	g_signal_connect (self->priv->greeter, "show-message", (GCallback) _greeter_show_message_cb_ldm_greeter_show_message, self);
	g_signal_connect (self->priv->greeter, "authentication-complete", (GCallback) _greeter_authentication_complete_cb_ldm_greeter_authentication_complete, self);
	g_signal_connect (self->priv->greeter, "timed-login", (GCallback) _greeter_timed_login_cb_ldm_greeter_timed_login, self);
	g_signal_connect (self->priv->greeter, "quit", (GCallback) _greeter_quit_cb_ldm_greeter_quit, self);
	return self;
}


Greeter* greeter_new (void) {
	return greeter_construct (TYPE_GREETER);
}


void greeter_start (Greeter* self) {
	g_return_if_fail (self != NULL);
	ldm_greeter_connect_to_server (self->priv->greeter);
}


static void greeter_username_activate_cb (Greeter* self, GtkEntry* entry) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (entry != NULL);
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->username_entry, FALSE);
	_tmp0_ = gtk_entry_get_text (self->priv->username_entry);
	ldm_greeter_login (self->priv->greeter, _tmp0_);
}


static void greeter_password_activate_cb (Greeter* self, GtkEntry* entry) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (entry != NULL);
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->password_entry, FALSE);
	_tmp0_ = gtk_entry_get_text (self->priv->password_entry);
	ldm_greeter_respond (self->priv->greeter, _tmp0_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _greeter_username_activate_cb_gtk_entry_activate (GtkEntry* _sender, gpointer self) {
	greeter_username_activate_cb (self, _sender);
}


static void _greeter_password_activate_cb_gtk_entry_activate (GtkEntry* _sender, gpointer self) {
	greeter_password_activate_cb (self, _sender);
}


static void greeter_connect_cb (Greeter* self, LdmGreeter* greeter) {
	GdkDisplay* _tmp0_ = NULL;
	GdkDisplay* _tmp1_;
	GdkDisplay* display;
	GdkScreen* _tmp2_ = NULL;
	GdkScreen* _tmp3_;
	GdkScreen* screen;
	GtkWindow* _tmp4_ = NULL;
	GtkWindow* window;
	gint _tmp5_;
	gint _tmp6_;
	GtkVBox* _tmp7_ = NULL;
	GtkVBox* vbox;
	GtkAlignment* _tmp8_ = NULL;
	GtkAlignment* login_align;
	GtkVBox* _tmp9_ = NULL;
	GtkVBox* login_vbox;
	GtkImage* _tmp10_ = NULL;
	GtkImage* logo_image;
	const gchar* _tmp11_ = NULL;
	GtkLabel* _tmp12_ = NULL;
	GtkLabel* _tmp13_;
	GtkLabel* _tmp14_ = NULL;
	GtkEntry* _tmp15_ = NULL;
	GtkEntry* _tmp16_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (greeter != NULL);
	_tmp0_ = gdk_display_get_default ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	display = _tmp1_;
	_tmp2_ = gdk_display_get_default_screen (display);
	_tmp3_ = _g_object_ref0 (_tmp2_);
	screen = _tmp3_;
	_tmp4_ = (GtkWindow*) gtk_window_new (GTK_WINDOW_TOPLEVEL);
	window = g_object_ref_sink (_tmp4_);
	_tmp5_ = gdk_screen_get_width (screen);
	_tmp6_ = gdk_screen_get_height (screen);
	gtk_window_set_default_size (window, _tmp5_, _tmp6_);
	_tmp7_ = (GtkVBox*) gtk_vbox_new (FALSE, 0);
	vbox = g_object_ref_sink (_tmp7_);
	gtk_container_add ((GtkContainer*) window, (GtkWidget*) vbox);
	_tmp8_ = (GtkAlignment*) gtk_alignment_new (0.5f, 0.5f, 0.0f, 0.0f);
	login_align = g_object_ref_sink (_tmp8_);
	gtk_box_pack_start ((GtkBox*) vbox, (GtkWidget*) login_align, TRUE, TRUE, (guint) 0);
	_tmp9_ = (GtkVBox*) gtk_vbox_new (FALSE, 6);
	login_vbox = g_object_ref_sink (_tmp9_);
	gtk_container_set_border_width ((GtkContainer*) login_vbox, (guint) 12);
	gtk_container_add ((GtkContainer*) login_align, (GtkWidget*) login_vbox);
	_tmp10_ = (GtkImage*) gtk_image_new_from_icon_name ("computer", GTK_ICON_SIZE_DIALOG);
	logo_image = g_object_ref_sink (_tmp10_);
	gtk_image_set_pixel_size (logo_image, 64);
	gtk_box_pack_start ((GtkBox*) login_vbox, (GtkWidget*) logo_image, FALSE, FALSE, (guint) 0);
	_tmp11_ = ldm_greeter_get_hostname (greeter);
	_tmp12_ = (GtkLabel*) gtk_label_new (_tmp11_);
	_tmp13_ = g_object_ref_sink (_tmp12_);
	gtk_box_pack_start ((GtkBox*) login_vbox, (GtkWidget*) _tmp13_, FALSE, FALSE, (guint) 0);
	_g_object_unref0 (_tmp13_);
	_tmp14_ = (GtkLabel*) gtk_label_new ("");
	_g_object_unref0 (self->priv->message_label);
	self->priv->message_label = g_object_ref_sink (_tmp14_);
	gtk_box_pack_start ((GtkBox*) login_vbox, (GtkWidget*) self->priv->message_label, FALSE, FALSE, (guint) 0);
	gtk_widget_set_no_show_all ((GtkWidget*) self->priv->message_label, TRUE);
	_tmp15_ = (GtkEntry*) gtk_entry_new ();
	_g_object_unref0 (self->priv->username_entry);
	self->priv->username_entry = g_object_ref_sink (_tmp15_);
	gtk_box_pack_start ((GtkBox*) login_vbox, (GtkWidget*) self->priv->username_entry, FALSE, FALSE, (guint) 0);
	g_signal_connect (self->priv->username_entry, "activate", (GCallback) _greeter_username_activate_cb_gtk_entry_activate, self);
	_tmp16_ = (GtkEntry*) gtk_entry_new ();
	_g_object_unref0 (self->priv->password_entry);
	self->priv->password_entry = g_object_ref_sink (_tmp16_);
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->password_entry, FALSE);
	gtk_box_pack_start ((GtkBox*) login_vbox, (GtkWidget*) self->priv->password_entry, FALSE, FALSE, (guint) 0);
	g_signal_connect (self->priv->password_entry, "activate", (GCallback) _greeter_password_activate_cb_gtk_entry_activate, self);
	gtk_widget_set_no_show_all ((GtkWidget*) self->priv->password_entry, TRUE);
	gtk_widget_show_all ((GtkWidget*) window);
	gtk_widget_grab_focus ((GtkWidget*) self->priv->username_entry);
	_g_object_unref0 (logo_image);
	_g_object_unref0 (login_vbox);
	_g_object_unref0 (login_align);
	_g_object_unref0 (vbox);
	_g_object_unref0 (window);
	_g_object_unref0 (screen);
	_g_object_unref0 (display);
}


static void greeter_show_prompt_cb (Greeter* self, LdmGreeter* greeter, const gchar* text, LdmPromptType type) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (greeter != NULL);
	g_return_if_fail (text != NULL);
	gtk_widget_show ((GtkWidget*) self->priv->password_entry);
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->password_entry, TRUE);
	gtk_entry_set_visibility (self->priv->password_entry, type != LDM_PROMPT_TYPE_SECRET);
	gtk_widget_grab_focus ((GtkWidget*) self->priv->password_entry);
}


static void greeter_show_message_cb (Greeter* self, LdmGreeter* greeter, const gchar* text, LdmMessageType type) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (greeter != NULL);
	g_return_if_fail (text != NULL);
	gtk_label_set_label (self->priv->message_label, text);
	gtk_widget_show ((GtkWidget*) self->priv->message_label);
}


static void greeter_authentication_complete_cb (Greeter* self, LdmGreeter* greeter) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (greeter != NULL);
	gtk_widget_hide ((GtkWidget*) self->priv->password_entry);
	gtk_entry_set_text (self->priv->password_entry, "");
	gtk_entry_set_text (self->priv->username_entry, "");
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->username_entry, TRUE);
	gtk_widget_grab_focus ((GtkWidget*) self->priv->username_entry);
	_tmp0_ = ldm_greeter_get_is_authenticated (greeter);
	if (_tmp0_) {
		ldm_greeter_start_default_session (greeter);
	} else {
		gtk_label_set_label (self->priv->message_label, "Failed to authenticate");
		gtk_widget_show ((GtkWidget*) self->priv->message_label);
	}
}


static void greeter_timed_login_cb (Greeter* self, LdmGreeter* greeter, const gchar* username) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (greeter != NULL);
	g_return_if_fail (username != NULL);
	_tmp0_ = ldm_greeter_get_timed_login_user (greeter);
	ldm_greeter_login (greeter, _tmp0_);
}


static void greeter_quit_cb (Greeter* self, LdmGreeter* greeter) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (greeter != NULL);
	gtk_main_quit ();
}


static gint greeter_main (gchar** args, int args_length1) {
	gint result = 0;
	Greeter* _tmp0_ = NULL;
	Greeter* g;
	gtk_init (&args_length1, &args);
	_tmp0_ = greeter_new ();
	g = _tmp0_;
	greeter_start (g);
	gtk_main ();
	result = 0;
	_greeter_unref0 (g);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return greeter_main (argv, argc);
}


static void value_greeter_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_greeter_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		greeter_unref (value->data[0].v_pointer);
	}
}


static void value_greeter_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = greeter_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_greeter_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_greeter_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Greeter* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = greeter_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_greeter_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Greeter** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = greeter_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_greeter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecGreeter* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_GREETER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_greeter (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GREETER), NULL);
	return value->data[0].v_pointer;
}


void value_set_greeter (GValue* value, gpointer v_object) {
	Greeter* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GREETER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GREETER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		greeter_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		greeter_unref (old);
	}
}


void value_take_greeter (GValue* value, gpointer v_object) {
	Greeter* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GREETER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GREETER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		greeter_unref (old);
	}
}


static void greeter_class_init (GreeterClass * klass) {
	greeter_parent_class = g_type_class_peek_parent (klass);
	GREETER_CLASS (klass)->finalize = greeter_finalize;
	g_type_class_add_private (klass, sizeof (GreeterPrivate));
}


static void greeter_instance_init (Greeter * self) {
	self->priv = GREETER_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void greeter_finalize (Greeter* obj) {
	Greeter * self;
	self = GREETER (obj);
	_g_object_unref0 (self->priv->greeter);
	_g_object_unref0 (self->priv->username_entry);
	_g_object_unref0 (self->priv->password_entry);
	_g_object_unref0 (self->priv->message_label);
}


GType greeter_get_type (void) {
	static volatile gsize greeter_type_id__volatile = 0;
	if (g_once_init_enter (&greeter_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_greeter_init, value_greeter_free_value, value_greeter_copy_value, value_greeter_peek_pointer, "p", value_greeter_collect_value, "p", value_greeter_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (GreeterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) greeter_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Greeter), 0, (GInstanceInitFunc) greeter_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType greeter_type_id;
		greeter_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Greeter", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&greeter_type_id__volatile, greeter_type_id);
	}
	return greeter_type_id__volatile;
}


gpointer greeter_ref (gpointer instance) {
	Greeter* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void greeter_unref (gpointer instance) {
	Greeter* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GREETER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



